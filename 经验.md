# Element-UI

## 布局

## 表单校验

1. 定义校验规则
2. 在 el-form 上绑定 rules
3. 在 el-form-item 上使用 prop 属性传入验证规则的名字

## 表单重置

使用 ref 引用表单元素，调用重置方法 resetFields

## 弹框提示

需要全局导入，挂在在 vue 原型上

```
import { Message } from 'element-ui'
Vue.prototype.$message = Message
```

## menu 菜单

如果要循环生成菜单，结构如下

```
// 用 el-submenu 生成一级菜单
// 用 <el-menu-item-group> 生成子菜单组容器，也可以不要。用了它会在子菜单顶部生成一个 padding 区域。
// 用 el-menu-item 生成子菜单
<el-menu>
<el-submenu
        v-for="menu in $store.state.menuList"
        :key="menu.id"
        :index="menu.id"
      >
        <template slot="title">
          <i class="el-icon-location"></i>
          <span>{{ menu.authName }}</span>
        </template>
        <el-menu-item-group>
          <el-menu-item v-for="m2 in menu.children" :key="m2.id" index="1-1">
            <i class="el-icon-menu"></i>
            <span>{{ m2.authName }}</span>
          </el-menu-item>
        </el-menu-item-group>
      </el-submenu>
</el-menu>
```

`collapse` 控制开关状态，`collapse-transition` 控制是否启用开关的动画效果。

把 form 的 router 设为 true，就会把菜单的 index 当作路由链接，点击菜单可以跳转。

让当前路由的对应菜单高亮，设置 form 的 default-active 属性为 router path，如果能匹配到某个菜单的 index 和 path 一致，就会让这个菜单高亮。

## 面包屑 el-breadcrumb

如果要让面包屑可以动态生成，最简单的办法是在 router 的 meta 里配置这个路由的所有面包屑信息，然后循环生成。

```
{
   path: '/users',
   name: 'users',
   component: () => import('@/views/Users.vue'),
   meta: {
     title: '用户管理',
     breadcrumb: [
       {
         title: '用户管理',
         path: '/users'
       }
     ]
   }
 }
 ```

如果是多层面包屑，这个 breadcrumb 里要把每一层都写进去。不需要写首页的，首页直接在面包屑里固定就行了。

页面里可以使用 `this.$route.meta.breadcrumb` 获取。

## 栅格

栅格总共为 24 等分，用 el-row 定义一层栅格，el-col 定义里面的一块区域。

栅格的好处是可以自适应宽度，并且固定比例。

## 表格

可以在某个列 el-table-column 上设置 `type=index`，这一列就会成为序号。

## 提示组件 tip

enterable 设置为 false 则鼠标可以穿透 tip，不会导致被提示遮挡的元素无法生效。

```
<el-tooltip
   class="item"
   effect="dark"
   content="删除"
   placement="top"
   :enterable="false"
 >
 </el-tooltip>
 ```

 ## 分页

 ```
 el-pagination
   @size-change="handleSizeChange"
   @current-change="handleCurrentChange"
   :current-page="pagenum"
   :page-sizes="[1, 2, 15, 20]"
   :page-size="pagesize"
   layout="total, sizes, prev, pager, next, jumper"
   :total="usersData.total"
 >
 </el-pagination>
 ```

绑定每页个数，以及当前页数。当发生对应事件时，改变查询参数，重新请求数据，重新渲染结果。

```
handleSizeChange(val: number) {
 this.pagesize = val
 this.getUserList()
}

handleCurrentChange(val: number) {
 this.pagenum = val
 this.getUserList()
}
```


## 开关 switch

switch 状态改变时会触发 change 事件，绑定一个处理方法，传递数据进行处理。

```
<template slot-scope="scope">
 <el-switch
   v-model="scope.row.mg_state"
   @change="userStateChange(scope.row)"
 >
 </el-switch>
</template>
```

## input

el-input 添加 clearable 可以清空。清空时会触发 clear 事件，可以监听这个事件进行对应操作。

此外输入框后面也可以添加按钮。

## slot-scope 作用域插槽

slot-scope 可以取到这一行的数据

```
// slot-scope 把插槽的数据绑定到了后面的 "scope" 数据上
<el-table-column prop="mg_state" label="状态">
  <template slot-scope="scope">
    {{ scope.row }}
  </template>
</el-table-column>
```

# 用户认证

## 登陆

登录成功后，将 token 保存到 sessionStorage 里，或者 vuex 里。

**区别：** 保存到 sessionStorage 里刷新页面不会导致重新登录。比较推荐。保存在 vuex 里刷新页面就没了，需要重新登录。

## 导航守卫

在 router 配置文件里，配置路由导航守卫，如果进入的页面网址是非登录页，就检测 token 是否存在，不存在则重定向至登陆页面。

```
router.beforeEach((to, from, next) => {
  if (to.path !== '/login' && !store.state.token) {
    return next('/login')
  } else {
    return next()
  }
})
```

## 登出

清空 token，跳转到登录页面。

## 携带认证信息

# Axios 

使用 .env.development 定义环境变量，设置 baseURL

axios 发起请求时要使用相对路径，baseURL 才会生效。如果使用绝对路径，就会忽略 baseURL。

## get 请求的参数

get 请求的参数是个对象，里面有个 params 属性：

```
this.axios.get('users', {
params: {
  query: this.query,
  pagenum: this.pagenum,
  pagesize: this.pagesize
}
})
```

## 拦截器

```

axios.interceptors.request.use(
  config => {
    const token = window.sessionStorage.getItem('token') || store.state.token
    config.headers.Authorization = token
    return config
  },
  err => {
    return Promise.reject(err)
  }
)

axios.interceptors.response.use(
  response => {
    // 对错误的状态码给出提示
    if (response?.data?.meta.status === 400) {
      console.error(response.config.baseURL)
    }
    // 如果状态码表示需要重新登录，则跳转到登录页面
    if (response?.data?.meta.status === 1001) {
       router.replace({
         path: 'login',
         query: {
           redirect: router.currentRoute.fullPath
         }
       })
    }

    return response
  },
  err => {
    return Promise.reject(err.response)
  }
)
```

# router 设置网页标题 title

在 router 信息里添加 title 信息，然后设置后导航守卫：

```
{
 path: '/login',
 name: 'login',
 component: () => import('@/views/Login.vue'),
 meta: {
   title: '用户登录'
 }
}
```

```
router.afterEach((to, from) => {
  if (to.meta.title) {
    document.title = to.meta.title
  }
})
```

# Eslint

修改规则，可能需要重启服务才会生效。

```
// 关闭规则：要求成员结尾都要有分号
"@typescript-eslint/member-delimiter-style": 0
```

错误级别
规则的错误级别分为三级：

0 或者"off" ，表示关闭规则。

1或者"warn" ，打开规则，并且将规则视为一个警告（并不会导致检查不通过）。

2或者"error" ，打开规则，并且将规则视为一个错误 (退出码为1，检查不通过)。
