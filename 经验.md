# Element-UI

## 布局

## 表单校验

1. 定义校验规则
2. 在 el-form 上绑定 rules
3. 在 el-form-item 上使用 prop 属性传入验证规则的名字
4. prop 传入的名字最好和这个输入框的 name 一致，否则可能验证不正常。

表单校验默认是回调形式，不给校验方法 validate 传入参数则是 promise，如下使用：

```
async check() {
 const r = await this.$refs.addRoleForm.validate().catch((err) => err)
 console.log(r)
}
```

## 表单重置

使用 ref 引用表单元素，调用重置方法 resetFields

## 弹框提示

需要全局导入，挂在在 vue 原型上

```
import { Message } from 'element-ui'
Vue.prototype.$message = Message
```

## menu 菜单

如果要循环生成菜单，结构如下

```
// 用 el-submenu 生成一级菜单
// 用 <el-menu-item-group> 生成子菜单组容器，也可以不要。用了它会在子菜单顶部生成一个 padding 区域。
// 用 el-menu-item 生成子菜单
<el-menu>
<el-submenu
        v-for="menu in $store.state.menuList"
        :key="menu.id"
        :index="menu.id"
      >
        <template slot="title">
          <i class="el-icon-location"></i>
          <span>{{ menu.authName }}</span>
        </template>
        <el-menu-item-group>
          <el-menu-item v-for="m2 in menu.children" :key="m2.id" index="1-1">
            <i class="el-icon-menu"></i>
            <span>{{ m2.authName }}</span>
          </el-menu-item>
        </el-menu-item-group>
      </el-submenu>
</el-menu>
```

`collapse` 控制开关状态，`collapse-transition` 控制是否启用开关的动画效果。

把 form 的 router 设为 true，就会把菜单的 index 当作路由链接，点击菜单可以跳转。

让当前路由的对应菜单高亮，设置 form 的 default-active 属性为 router path，如果能匹配到某个菜单的 index 和 path 一致，就会让这个菜单高亮。

## 面包屑 el-breadcrumb

如果要让面包屑可以动态生成，最简单的办法是在 router 的 meta 里配置这个路由的所有面包屑信息，然后循环生成。

```
{
   path: '/users',
   name: 'users',
   component: () => import('@/views/Users.vue'),
   meta: {
     title: '用户管理',
     breadcrumb: [
       {
         title: '用户管理',
         path: '/users'
       }
     ]
   }
 }
 ```

如果是多层面包屑，这个 breadcrumb 里要把每一层都写进去。不需要写首页的，首页直接在面包屑里固定就行了。

页面里可以使用 `this.$route.meta.breadcrumb` 获取。

## 栅格

栅格总共为 24 等分，用 el-row 定义一层栅格，el-col 定义里面的一块区域。

栅格的好处是可以自适应宽度，并且固定比例。

## 表格

可以在某个列 el-table-column 上设置 `type=index`，这一列就会成为序号。

## 提示组件 tip

enterable 设置为 false 则鼠标可以穿透 tip，不会导致被提示遮挡的元素无法生效。

```
<el-tooltip
   class="item"
   effect="dark"
   content="删除"
   placement="top"
   :enterable="false"
 >
 </el-tooltip>
 ```

 ## 分页

 ```
 el-pagination
   @size-change="handleSizeChange"
   @current-change="handleCurrentChange"
   :current-page="pagenum"
   :page-sizes="[1, 2, 15, 20]"
   :page-size="pagesize"
   layout="total, sizes, prev, pager, next, jumper"
   :total="usersData.total"
 >
 </el-pagination>
 ```

绑定每页个数，以及当前页数。当发生对应事件时，改变查询参数，重新请求数据，重新渲染结果。

```
handleSizeChange(val: number) {
 this.pagesize = val
 this.getUserList()
}

handleCurrentChange(val: number) {
 this.pagenum = val
 this.getUserList()
}
```


## 开关 switch

switch 状态改变时会触发 change 事件，绑定一个处理方法，传递数据进行处理。

```
<template slot-scope="scope">
 <el-switch
   v-model="scope.row.mg_state"
   @change="userStateChange(scope.row)"
 >
 </el-switch>
</template>
```

## input

el-input 添加 clearable 可以清空。清空时会触发 clear 事件，可以监听这个事件进行对应操作。

此外输入框后面也可以添加按钮。

## slot-scope 作用域插槽

slot-scope 可以取到这一行的数据

```
// slot-scope 把插槽的数据绑定到了后面的 "scope" 变量上。如果要定义多个 slot-scope，后面的变量名需要不一样。
<el-table-column prop="mg_state" label="状态">
  <template slot-scope="scope">
    {{ scope.row }}
  </template>
</el-table-column>
```

## MessageBox

MessageBox 包含 alert、confirm、prompt 方法。调用方法是导入 MessageBox，挂载到 vue 原型上。

```
import { MessageBox } from 'element-ui'
Vue.prototype.$messageBox = MessageBox
// 或者单独挂载一个方法
Vue.prototype.$confirm = MessageBox.confirm
```

调用具体的方法时，通过 $messageBox 引用，如

```
this.$messageBox.confirm
```

## confirm

用 await confirm 取得的结果是字符串

```
confirm
cancel
close
```

`close` 是当 confirm 设置了 `distinguishCancelAndClose: true,` 参数时，关闭对话框时会返回。（点击关闭按钮或遮罩层、按下 ESC 键）

如果没有设置这个属性，关闭对话框会返回 `cancel`

## Dialog

Dialog 的取消按钮只负责隐藏对话框就行，如果要清空数据之类的其他操作，用 dialog 上的 @close 事件就行了。点击取消按钮也会触发 close 事件。

## Tree 树形结构

树形结构需要有对应的树形数据。

```
// props 定义这个列表显示的 lable 是哪个属性，子节点是哪个属性名。
:props="treeProps"

treeProps = {
 label: 'authName',
 children: 'children'
}

// data 定义要使用的数据
:data="rightTreeData"

// node-key 定义节点的值是每一层的哪个属性
node-key="id"

// :default-checked-keys 提供一个数组，里面的值需要是 node-key 属性里的值。
// 如果 :default-checked-keys 里的值符合某个节点的 id，就会自动选中这个节点
:default-checked-keys="defaultCheckKeys"

// 默认展开所有
default-expand-all

// 显示复选框
show-checkbox
```

使用 `getCheckedKeys` 方法可以获取到所有选中的值，使用 `getHalfCheckedKeys` 获取所有半选中的值。很多时候这俩都需要获取的。

## 树形表格

在 el-table 上设置这个属性，就可以让表格自动识别出树形结构，自动添加展开按钮。

```
:tree-props="{ children: 'children' }"
```

## Loading 加载进度条

引入 Loading 组件，然后在要显示进度的元素上设置 v-loading 指令，加载状态绑定一个变量。

```
div v-loading="loading"
```

## 级联选择器

级联选择器使用的数据，默认需要包含 label 属性和 value 等属性。如果要使用的数据里，对应的属性名和默认的不同，可以通过 props 属性进行设置。

```
<el-cascader
  v-model="chooseCate"
  :options="parentCateList"
  :props="{
    expandTrigger: 'hover',
    value: 'cat_id',
    label: 'cat_name'
    checkStrictly: true
  }"
  clearable
  ref="chooseRef"
></el-cascader>
```

## Tabs 选项卡

```
<el-tabs v-model="activeName" @tab-click="tabsClick">
<el-tab-pane label="动态参数" name="async"></el-tab-pane>
</el-tabs>
```

`@tab-click` 事件绑定一个方法，可以从第一个参数的 name 取得点击后激活的 tab 的 name。

```
handleClick(tab, event) {
   this.activeName = tab.name
}
```

# 用户认证

## 登陆

登录成功后，将 token 保存到 sessionStorage 里，或者 vuex 里。

**区别：** 保存到 sessionStorage 里刷新页面不会导致重新登录。比较推荐。保存在 vuex 里刷新页面就没了，需要重新登录。

## 导航守卫

在 router 配置文件里，配置路由导航守卫，如果进入的页面网址是非登录页，就检测 token 是否存在，不存在则重定向至登陆页面。

```
router.beforeEach((to, from, next) => {
  if (to.path !== '/login' && !store.state.token) {
    return next('/login')
  } else {
    return next()
  }
})
```

## 登出

清空 token，跳转到登录页面。

## 携带认证信息

# Axios 

使用 .env.development 定义环境变量，设置 baseURL

axios 发起请求时要使用相对路径，baseURL 才会生效。如果使用绝对路径，就会忽略 baseURL。

## get 请求的参数

get 请求的参数是个对象，里面有个 params 属性：

```
this.axios.get('users', {
params: {
  query: this.query,
  pagenum: this.pagenum,
  pagesize: this.pagesize
}
})
```

## 拦截器

```

axios.interceptors.request.use(
  config => {
    const token = window.sessionStorage.getItem('token') || store.state.token
    config.headers.Authorization = token
    return config
  },
  err => {
    return Promise.reject(err)
  }
)

axios.interceptors.response.use(
  response => {
    // 对错误的状态码给出提示
    if (response?.data?.meta.status === 400) {
      console.error(response.config.baseURL)
    }
    // 如果状态码表示需要重新登录，则跳转到登录页面
    if (response?.data?.meta.status === 1001) {
       router.replace({
         path: 'login',
         query: {
           redirect: router.currentRoute.fullPath
         }
       })
    }

    return response
  },
  err => {
    return Promise.reject(err.response)
  }
)
```

# Router

## 设置网页标题 title

在 router 信息里添加 title 信息，然后设置后导航守卫：

```
{
 path: '/login',
 name: 'login',
 component: () => import('@/views/Login.vue'),
 meta: {
   title: '用户登录'
 }
}
```

```
router.afterEach((to, from) => {
  if (to.meta.title) {
    document.title = to.meta.title
  }
})
```

## Redirected ... via a navigation guard

`Redirected when going from "/login" to "/" via a navigation guard.`

可以在 router/index.js 里添加如下代码解决。这个错误可能是因为连续的重定向导致的（push 可能在某些情况下存在一定问题）。

```
const originalPush = VueRouter.prototype.push
VueRouter.prototype.push = function push(location, onResolve, onReject) {
    if (onResolve || onReject) return originalPush.call(this, location, onResolve, onReject)
    return originalPush.call(this, location).catch(err => err)
}
```

或者，把某些 push 改成直接设置 url。如 login 之后本来是 `push('/')` 的，`/` 又会重定向到 '/users' 页面，结果出现了上面的错误。改成 `location.href = '/'` 之后就没有这个错误了。

# Eslint

修改规则，可能需要重启服务才会生效。

```
// 关闭规则：要求成员结尾都要有分号
"@typescript-eslint/member-delimiter-style": 0
```

错误级别
规则的错误级别分为三级：

0 或者"off" ，表示关闭规则。

1或者"warn" ，打开规则，并且将规则视为一个警告（并不会导致检查不通过）。

2或者"error" ，打开规则，并且将规则视为一个错误 (退出码为1，检查不通过)。

# 电商后台用户权限架构

一个用户可以扮演多个角色，每个角色又有一定的权限。这形成了用户权限架构。

# 电商产品的参数管理

一个商品有动态参数和静态属性。

动态参数比如手机的规格： 128G 256G 银色 蓝色

静态属性是这类商品必填的属性，如 品牌、型号、重量 等。

# 局部更新数据防止页面抖动（重绘）

比如一个复杂的表格，我们修改了其中一部分数据，如果可以，应该尽量更新这一部分的数据，而不是重新请求/赋值整个数据，因为整个修改数据会导致大范围重绘，局部更新可以保持状态，不必重绘。

比如修改了一个对象的 name 属性，应该把 name 设置为新的值，而不是重新请求这个对象。

# Vue 监听对象和数组变化

如果是整个重新赋值，不用特殊处理。

当需要局部修改/赋值某个属性时，才需要特殊处理。

数组有些方法比如 push，slice 也是可以直接用的。

# 递归的注意事项

比如一个对象，children 节点可能又嵌套 children，有很多层。用一个递归函数一直查找到最后一层。没有 children 的是最后一层，如果有 children 就继续向下查找。

注意递归函数调用自身时，不要返回 return。否则执行到最后一层时，如果这个递归函数产生了很多个同时运行的自身函数，会在第一次就返回了，导致获取不到后续的自身函数的结果。

```
getRightIds(node, arr) {
 if (!node.children) {
   console.log(node.id)
   return arr.push(node.id)
 }

 for (const children of node.children) {
   // 继续向下查找，这里不要 return
   this.getRightIds(children, arr)
 }
}
```

# 树形表格 TreeTable

## 推荐使用 element 的树形表格

在 el-table 上设置这个属性，就可以让表格自动识别出树形结构，自动添加展开按钮。

```
:tree-props="{ children: 'children' }"
```

## 第三方插件

https://www.npmjs.com/package/vue-table-with-tree-grid

```
npm i -S vue-table-with-tree-grid

// main 中引入，注册为一个 vue 组件
import TreeTable from 'vue-table-with-tree-grid'
Vue.component('tree-table', TreeTable)

// ts 项目可能需要建立一个 .d.ts 文件，声明这是一个模块
declare module 'vue-table-with-tree-grid'

//添加到全局 Vue 的 components 上
new Vue({
  router,
  store,
  components: { TreeTable },
  render: h => h(App)
}).$mount('#app')

// 在其他组件中直接使用
<tree-table :data="cateList"></tree-table>
```

# 检查空值

对字符串使用 `trim` 方法去除首位的空格。