# Element-UI

## 布局

## input 类型

```
<el-input
                  type="number"
                  v-model="formData.goods_weight"
                ></el-input>
```

设置 `type="number"` 可以只允许输入数字，并且会显示右侧调整数量的控件。

## 表单校验

1. 定义校验规则
2. 在 el-form 上绑定 rules
3. 在 el-form-item 上使用 prop 属性传入验证规则的名字
4. prop 传入的名字最好和这个输入框的 name 一致，否则可能验证不正常。


表单校验默认是回调形式，不给校验方法 validate 传入参数则是 promise，如下使用：

```
async check() {
 const r = await this.$refs.addRoleForm.validate().catch((err) => err)
 console.log(r)
}
```

## 如果验证的值是数字

首先 input 指定类型为 number

```
<el-input
   type="number"
   v-model.number="formData.goods_number"
 ></el-input>
 ```

然后验证规则里也要加上类型说明：

```
{ type: 'number', min: 1, message: '商品数量不能为空', trigger: 'blur' }
```

## 表单重置

使用 ref 引用表单元素，调用重置方法 resetFields

## 弹框提示

需要全局导入，挂在在 vue 原型上

```
import { Message } from 'element-ui'
Vue.prototype.$message = Message
```

## menu 菜单

如果要循环生成菜单，结构如下

```
// 用 el-submenu 生成一级菜单
// 用 <el-menu-item-group> 生成子菜单组容器，也可以不要。用了它会在子菜单顶部生成一个 padding 区域。
// 用 el-menu-item 生成子菜单
<el-menu>
<el-submenu
        v-for="menu in $store.state.menuList"
        :key="menu.id"
        :index="menu.id"
      >
        <template slot="title">
          <i class="el-icon-location"></i>
          <span>{{ menu.authName }}</span>
        </template>
        <el-menu-item-group>
          <el-menu-item v-for="m2 in menu.children" :key="m2.id" index="1-1">
            <i class="el-icon-menu"></i>
            <span>{{ m2.authName }}</span>
          </el-menu-item>
        </el-menu-item-group>
      </el-submenu>
</el-menu>
```

`collapse` 控制开关状态，`collapse-transition` 控制是否启用开关的动画效果。

把 form 的 router 设为 true，就会把菜单的 index 当作路由链接，点击菜单可以跳转。

让当前路由的对应菜单高亮，设置 form 的 default-active 属性为 router path，如果能匹配到某个菜单的 index 和 path 一致，就会让这个菜单高亮。

## 面包屑 el-breadcrumb

如果要让面包屑可以动态生成，最简单的办法是在 router 的 meta 里配置这个路由的所有面包屑信息，然后循环生成。

```
{
   path: '/users',
   name: 'users',
   component: () => import('@/views/Users.vue'),
   meta: {
     title: '用户管理',
     breadcrumb: [
       {
         title: '用户管理',
         path: '/users'
       }
     ]
   }
 }
 ```

如果是多层面包屑，这个 breadcrumb 里要把每一层都写进去。不需要写首页的，首页直接在面包屑里固定就行了。

页面里可以使用 `this.$route.meta.breadcrumb` 获取。

## 栅格

栅格总共为 24 等分，用 el-row 定义一层栅格，el-col 定义里面的一块区域。

栅格的好处是可以自适应宽度，并且固定比例。

## 表格

可以在某个列 el-table-column 上设置 `type=index`，这一列就会成为序号。

## 提示组件 tip

enterable 设置为 false 则鼠标可以穿透 tip，不会导致被提示遮挡的元素无法生效。

```
<el-tooltip
   class="item"
   effect="dark"
   content="删除"
   placement="top"
   :enterable="false"
 >
 </el-tooltip>
 ```

 ## 分页

 ```
 el-pagination
   @size-change="handleSizeChange"
   @current-change="handleCurrentChange"
   :current-page="pagenum"
   :page-sizes="[1, 2, 15, 20]"
   :page-size="pagesize"
   layout="total, sizes, prev, pager, next, jumper"
   :total="usersData.total"
 >
 </el-pagination>
 ```

绑定每页个数，以及当前页数。当发生对应事件时，改变查询参数，重新请求数据，重新渲染结果。

```
handleSizeChange(val: number) {
 this.pagesize = val
 this.getUserList()
}

handleCurrentChange(val: number) {
 this.pagenum = val
 this.getUserList()
}
```


## 开关 switch

switch 状态改变时会触发 change 事件，绑定一个处理方法，传递数据进行处理。

```
<template slot-scope="scope">
 <el-switch
   v-model="scope.row.mg_state"
   @change="userStateChange(scope.row)"
 >
 </el-switch>
</template>
```

## input

el-input 添加 clearable 可以清空。清空时会触发 clear 事件，可以监听这个事件进行对应操作。

此外输入框后面也可以添加按钮。

## slot-scope 作用域插槽

slot-scope 可以取到这一行的数据

```
// slot-scope 把插槽的数据绑定到了后面的 "scope" 变量上。如果要定义多个 slot-scope，后面的变量名需要不一样。
<el-table-column prop="mg_state" label="状态">
  <template slot-scope="scope">
    {{ scope.row }}
  </template>
</el-table-column>
```

## MessageBox

MessageBox 包含 alert、confirm、prompt 方法。调用方法是导入 MessageBox，挂载到 vue 原型上。

```
import { MessageBox } from 'element-ui'
Vue.prototype.$messageBox = MessageBox
// 或者单独挂载一个方法
Vue.prototype.$confirm = MessageBox.confirm
```

调用具体的方法时，通过 $messageBox 引用，如

```
this.$messageBox.confirm
```

## confirm

用 await confirm 取得的结果是字符串

```
confirm
cancel
close
```

`close` 是当 confirm 设置了 `distinguishCancelAndClose: true,` 参数时，关闭对话框时会返回。（点击关闭按钮或遮罩层、按下 ESC 键）

如果没有设置这个属性，关闭对话框会返回 `cancel`

## Dialog

Dialog 的取消按钮只负责隐藏对话框就行，如果要清空数据之类的其他操作，用 dialog 上的 @close 事件就行了。点击取消按钮也会触发 close 事件。

## Tree 树形结构

树形结构需要有对应的树形数据。

```
// props 定义这个列表显示的 lable 是哪个属性，子节点是哪个属性名。
:props="treeProps"

treeProps = {
 label: 'authName',
 children: 'children'
}

// data 定义要使用的数据
:data="rightTreeData"

// node-key 定义节点的值是每一层的哪个属性
node-key="id"

// :default-checked-keys 提供一个数组，里面的值需要是 node-key 属性里的值。
// 如果 :default-checked-keys 里的值符合某个节点的 id，就会自动选中这个节点
:default-checked-keys="defaultCheckKeys"

// 默认展开所有
default-expand-all

// 显示复选框
show-checkbox
```

使用 `getCheckedKeys` 方法可以获取到所有选中的值，使用 `getHalfCheckedKeys` 获取所有半选中的值。很多时候这俩都需要获取的。

## 树形表格

在 el-table 上设置这个属性，就可以让表格自动识别出树形结构，自动添加展开按钮。

```
:tree-props="{ children: 'children' }"
```

## Loading 加载进度条

引入 Loading 组件，然后在要显示进度的元素上设置 v-loading 指令，加载状态绑定一个变量。

```
div v-loading="loading"
```

## 级联选择器

级联选择器使用的数据，默认需要包含 label 属性和 value 等属性。如果要使用的数据里，对应的属性名和默认的不同，可以通过 props 属性进行设置。

```
<el-cascader
  v-model="chooseCate"
  :options="parentCateList"
  :props="{
    expandTrigger: 'hover',
    value: 'cat_id',
    label: 'cat_name',
    checkStrictly: true
  }"
  clearable
  ref="chooseRef"
></el-cascader>
```

## Tabs 选项卡

```
<el-tabs v-model="activeName" @tab-click="tabsClick">
<el-tab-pane label="动态参数" name="async"></el-tab-pane>
</el-tabs>
```

`@tab-click` 事件绑定一个方法，可以从第一个参数的 name 取得点击后激活的 tab 的 name。

```
handleClick(tab, event) {
   this.activeName = tab.name
}
```

### 阻止切换

`before-leave` 事件可以返回一个 boolean 值，决定是否允许这次切换。

## Upload

使用 Upload 组件上传时，如果需要携带 token 等请求头，可以自定义一个，绑定到 headers 属性上。

```
<el-upload
 action="http://127.0.0.1:8888/api/private/v1/upload"
 :on-preview="handlePreview"
 :on-remove="handleRemove"
 list-type="picture"
 :headers="headerObj"
>
 <el-button size="small" type="primary">点击上传</el-button>
 <div slot="tip" class="el-upload__tip">
   只能上传jpg/png文件，且不超过500kb
 </div>
</el-upload>

// js
headerObj = {
 Authorization: window.sessionStorage.getItem('token')
}
```


# 用户认证

## 登陆

登录成功后，将 token 保存到 sessionStorage 里，或者 vuex 里。

**区别：** 保存到 sessionStorage 里刷新页面不会导致重新登录。比较推荐。保存在 vuex 里刷新页面就没了，需要重新登录。

## 导航守卫

在 router 配置文件里，配置路由导航守卫，如果进入的页面网址是非登录页，就检测 token 是否存在，不存在则重定向至登陆页面。

```
router.beforeEach((to, from, next) => {
  if (to.path !== '/login' && !store.state.token) {
    return next('/login')
  } else {
    return next()
  }
})
```

## 登出

清空 token，跳转到登录页面。

## 携带认证信息

# Axios 

使用 .env.development 定义环境变量，设置 baseURL

axios 发起请求时要使用相对路径，baseURL 才会生效。如果使用绝对路径，就会忽略 baseURL。

## get 请求的参数

get 请求的参数是个对象，里面有个 params 属性：

```
this.axios.get('users', {
params: {
  query: this.query,
  pagenum: this.pagenum,
  pagesize: this.pagesize
}
})
```

## 拦截器

```

axios.interceptors.request.use(
  config => {
    const token = window.sessionStorage.getItem('token') || store.state.token
    config.headers.Authorization = token
    return config
  },
  err => {
    return Promise.reject(err)
  }
)

axios.interceptors.response.use(
  response => {
    // 对错误的状态码给出提示
    if (response?.data?.meta.status === 400) {
      console.error(response.config.baseURL)
    }
    // 如果状态码表示需要重新登录，则跳转到登录页面
    if (response?.data?.meta.status === 1001) {
       router.replace({
         path: 'login',
         query: {
           redirect: router.currentRoute.fullPath
         }
       })
    }

    return response
  },
  err => {
    return Promise.reject(err.response)
  }
)
```

# Router

## 设置网页标题 title

在 router 信息里添加 title 信息，然后设置后导航守卫：

```
{
 path: '/login',
 name: 'login',
 component: () => import('@/views/Login.vue'),
 meta: {
   title: '用户登录'
 }
}
```

```
router.afterEach((to, from) => {
  if (to.meta.title) {
    document.title = to.meta.title
  }
})
```

## Redirected ... via a navigation guard

`Redirected when going from "/login" to "/" via a navigation guard.`

可以在 router/index.js 里添加如下代码解决。这个错误可能是因为连续的重定向导致的（push 可能在某些情况下存在一定问题）。

```
const originalPush = VueRouter.prototype.push
VueRouter.prototype.push = function push(location, onResolve, onReject) {
    if (onResolve || onReject) return originalPush.call(this, location, onResolve, onReject)
    return originalPush.call(this, location).catch(err => err)
}
```

或者，把某些 push 改成直接设置 url。如 login 之后本来是 `push('/')` 的，`/` 又会重定向到 '/users' 页面，结果出现了上面的错误。改成 `location.href = '/'` 之后就没有这个错误了。

# Eslint

修改规则，可能需要重启服务才会生效。

```
// 关闭规则：要求成员结尾都要有分号
"@typescript-eslint/member-delimiter-style": 0
```

错误级别
规则的错误级别分为三级：

0 或者"off" ，表示关闭规则。

1或者"warn" ，打开规则，并且将规则视为一个警告（并不会导致检查不通过）。

2或者"error" ，打开规则，并且将规则视为一个错误 (退出码为1，检查不通过)。

# 电商后台用户权限架构

一个用户可以扮演多个角色，每个角色又有一定的权限。这形成了用户权限架构。

# 电商产品的参数管理

一个商品有动态参数和静态属性。

动态参数比如手机的规格： 128G 256G 银色 蓝色

静态属性是这类商品必填的属性，如 品牌、型号、重量 等。

# 局部更新数据防止页面抖动（重绘）

比如一个复杂的表格，我们修改了其中一部分数据，如果可以，应该尽量更新这一部分的数据，而不是重新请求/赋值整个数据，因为整个修改数据会导致大范围重绘，局部更新可以保持状态，不必重绘。

比如修改了一个对象的 name 属性，应该把 name 设置为新的值，而不是重新请求这个对象。

# Vue 监听对象和数组变化

如果是整个重新赋值，不用特殊处理。

当需要局部修改/赋值某个属性时，才需要特殊处理。

数组有些方法比如 push，slice 也是可以直接用的。

# 递归的注意事项

比如一个对象，children 节点可能又嵌套 children，有很多层。用一个递归函数一直查找到最后一层。没有 children 的是最后一层，如果有 children 就继续向下查找。

注意递归函数调用自身时，不要返回 return。否则执行到最后一层时，如果这个递归函数产生了很多个同时运行的自身函数，会在第一次就返回了，导致获取不到后续的自身函数的结果。

```
getRightIds(node, arr) {
 if (!node.children) {
   console.log(node.id)
   return arr.push(node.id)
 }

 for (const children of node.children) {
   // 继续向下查找，这里不要 return
   this.getRightIds(children, arr)
 }
}
```

# 树形表格 TreeTable

## 推荐使用 element 的树形表格

在 el-table 上设置这个属性，就可以让表格自动识别出树形结构，自动添加展开按钮。

```
:tree-props="{ children: 'children' }"
```

## 第三方插件

https://www.npmjs.com/package/vue-table-with-tree-grid

```
npm i -S vue-table-with-tree-grid

// main 中引入，注册为一个 vue 组件
import TreeTable from 'vue-table-with-tree-grid'
Vue.component('tree-table', TreeTable)

// ts 项目可能需要建立一个 .d.ts 文件，声明这是一个模块
declare module 'vue-table-with-tree-grid'

//添加到全局 Vue 的 components 上
new Vue({
  router,
  store,
  components: { TreeTable },
  render: h => h(App)
}).$mount('#app')

// 在其他组件中直接使用
<tree-table :data="cateList"></tree-table>
```

# 检查空值

对字符串使用 `trim` 方法去除首位的空格。

# 富文本编辑器

vue-quill-editor 富文本编辑器使用

https://www.jianshu.com/p/a6cba69d6e49

它可以 v-model 一个数据，使用很方便。返回的值是带有 html 标签的文本。


```
<quillEditor v-model="formData.goods_introduce"></quillEditor>
```
# vue 里引入静态 js 文件

文件最好放在 assets 里

```
<!-- 在 js 顶部引入 -->
import city from '@/utils/citydata.js'
// 在 data 里面再用一个变量引用它，这样才能使用
city = city
```

# Echarts

引入 echarts，给它一个 dom 元素初始化，最后传递数据。

```
import echarts from 'echarts'

echarts = echarts

// 初始化
const myChart = this.echarts.init(this.$refs.echartsRef)
// 绘制图表
const data = await this.getReportData()
myChart.setOption(data)
```

# nprogress 页面加载进度条

```
npm install --save nprogress
```

用法

```
NProgress.start();
NProgress.done();
```

可以在路由里使用，进入页面之前显示进度条，进入页面之后隐藏进度条。

也可以在 axios 拦截器中使用，发起请求时显示进度条，response 时隐藏进度条。

router.js 中使用：

```
//导入
import NProgress from 'nprogress'
import 'nprogress/nprogress.css'

router.beforeEach((to, from, next) => {
  NProgress.start()
  next()
})

router.afterEach(() => {
  NProgress.done()
})
```

拦截器使用：

```
axios.interceptors.request.use(
  config => {
    NProgress.start()
    return config
  },
  err => {
    return Promise.reject(err)
  }
)

axios.interceptors.response.use(
  response => {
    NProgress.done()
    return response
  },
  err => {
    return Promise.reject(err.response)
  }
)
```

# 项目打包优化

## 打包优化

参考列表

vue-cli3项目打包优化 
https://segmentfault.com/a/1190000021477337

Vue电商后台管理系统 打包优化

https://naccl.top/blog/15

### 移除项目文件里的 console.log 代码

使用 babel 插件 `babel-plugin-transform-remove-console`。

```
npm install babel-plugin-transform-remove-console --save-dev
```

.babelrc 或者 babel.config.js 里添加这个插件
```
// without options
{
  "plugins": ["transform-remove-console"]
}

// with options
{
  "plugins": [ ["transform-remove-console", { "exclude": [ "error", "warn"] }] ]
}
```

如果要只在生产环境中让它生效，可以判断环境变量，如下：

```
const propPlugins = []
// 只在生产环境里启用的插件
if (process.env.NODE_ENV === 'prodution') {
  propPlugins.push('transform-remove-console')
}

module.exports = {
  presets: ['@vue/app', ['@babel/preset-env', { modules: false }]],
  plugins: [
    [
      'component',
      {
        libraryName: 'element-ui',
        styleLibraryName: 'theme-chalk'
      }
    ],
    ...propPlugins
  ]
}
```

### 生成打包报告

```
npm run build --report
```

或者通过 vue ui 启动 gui，在里面打包，可以查看报告。

### 通过 vue.config.js 优化配置

新建  vue.config.js文件。

可以定义 configureWebpack 或者 chainWebpack 定义打包方式。作用是相同的，只是方式不同。


#### 不生成 sourceMap 文件

```
module.exports = {
  productionSourceMap: false,
}
```

#### chainWebpack 自定义打包入口

修改打包入口

#### 使用 htmlWebpackPlugin 区分不同模式

```
module.exports = {
  productionSourceMap: false,

  chainWebpack: config => {
    // 发布模式
    config.when(process.env.NODE_ENV === 'production', config => {
      // 设置入口文件
      config.entry('app').clear().add('./src/main-prod.ts')

      // 使用 externals 抽离依赖项，设置在这里的依赖项不会被打包，所以我们可以用 cdn 引入这些依赖
      config.set(['externals', {
        vue: 'Vue',
        'vue-router': 'VueRouter'
      }])
      // 左侧是这些依赖的包名，右侧是这些依赖在使用中的名字

      // 设置 htmlWebpackPlugin 插件上的标识
      config.plugin('html').tap(args => {
        args[0].isProd = true
        return args
      })
    })

    // 开发模式
    config.when(process.env.NODE_ENV === 'development', config => {
      // 设置入口文件
      config.entry('app').clear().add('./src/main-dev.ts')

      // 设置 htmlWebpackPlugin 插件上的标识
      config.plugin('html').tap(args => {
        args[0].isProd = false
        return args
      })
    })
  }
}

```

在 public/index.html 中可以读取这个设置，在不同模式下显示/输出不同内容。

```
<span><%= htmlWebpackPlugin.options.isProd ? 'pro' : 'dev' %></span>
```

## 使用 cdn 加载部分资源

例如下面的 cdn 资源优化，需要判断只在生产环境下才添加那些 cdn 的链接。开发模式下不需要使用 cdn。

```
<% if(htmlWebpackPlugin.options.isProd){ %>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
<% } %>
```

#### 设置 externals 不打包某些资源，改用 cdn

```
config.set(['externals', {
  vue: 'Vue',
  'vue-router': 'VueRouter'
}])
```

左边的 key 是包名，右侧的是项目里引入这些包时使用的名称

然后在**打包后的** dist/index.html 里添加这些资源的 cdn 资源

```
<% if(htmlWebpackPlugin.options.isProd){ %>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script src="https://unpkg.com/vue-router/dist/vue-router.js"></script>
<% } %>
```

#### 使用 cdn 加载 Element-ui

这个地方遇到了很多问题。目前没能彻底将其分离。

先配置生产环境中不打包 element-ui。然后在 index.html 里加载 css 和 js。

```
config.set(['externals', {
  vue: 'Vue',
  nprogress: 'NProgress',
  'element-ui': 'ELEMENT'
}]
```

```
 <link
   rel="stylesheet"
   href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"
 />
 <script src="https://unpkg.com/element-ui/lib/index.js"></script>
```

项目中对 element-ui 是按需引入的，如果注释掉了对它的引入，打包后的项目里 element-ui 就跟没生效一样。所以没有注释掉它的引入。可以注释掉 main.js 里对它的 css 的引入。

## 组件按需加载 懒加载

## 路由按需加载 懒加载

# 项目上线

创建个文件夹作为网站目录，`npm init -y` 初始化一下。

把打包生成的 dist 文件夹拷贝进来，然后用 nodejs 的一些后台框架创建网站。

## 创建网站

## 开启 Gzip 压缩

需要服务端启用 Gzip 压缩。 express 框架可以使用 compression 中间件。

## 导入 https 证书使用

## 使用 pm2 管理

```
npm i -g pm2
```

$ pm2 start app.js  启动app项目

$ pm2 start app.js --name name  启动app项目，并设置别名

$ pm2 list 列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。

 

$ pm2 monit 监视每个node进程的CPU和内存的使用情况

$ pm2 logs 显示所有进程日志

$ pm2 stop all 停止所有进程

$ pm2 restart all 重启所有进程

$ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程)

$ pm2 stop 0 停止指定的进程

$ pm2 restart 0 重启指定的进程

$ pm2 startup 产生 init 脚本 保持进程活着

$ pm2 web 运行健壮的 computer API endpoint (http://localhost:9615)

$ pm2 delete 0 杀死指定的进程

$ pm2 delete all 杀死全部进程